/*----------------------------------------------------------------------------*/
/* Copyright (c) 2017-2018 FIRST. All Rights Reserved.                        */
/* Open Source Software - may be modified and shared by FRC teams. The code   */
/* must be accompanied by the FIRST BSD license file in the root directory of */
/* the project.                                                               */
/*----------------------------------------------------------------------------*/

package frc.robot;

import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.PWMVictorSPX;
import edu.wpi.first.wpilibj.TimedRobot;
import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.drive.DifferentialDrive;
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;
import edu.wpi.first.wpilibj.SpeedControllerGroup;
import edu.wpi.first.wpilibj.Servo;
import edu.wpi.first.wpilibj.Solenoid;
import edu.wpi.first.wpilibj.SolenoidBase;
import edu.wpi.first.wpilibj.Spark;
import edu.wpi.first.wpilibj.CameraServer;
import edu.wpi.first.wpilibj.IterativeRobot;
import edu.wpi.first.wpilibj.AnalogInput;
import edu.wpi.first.wpilibj.DigitalOutput;
/**
 * The VM is configured to automatically run this class, and to call the
 * functions corresponding to each mode, as described in the TimedRobot
 * documentation. If you change the name of this class or the package after
 * creating this project, you must also update the manifest file in the resource
 * directory.
 */
public class Robot extends TimedRobot {
  WPI_TalonSRX rightFront_master = new WPI_TalonSRX(2); //assign TALON chain number
  WPI_TalonSRX rightFront_slave  = new WPI_TalonSRX(4);
  SpeedControllerGroup m_right = new SpeedControllerGroup(rightFront_master, rightFront_slave);

  WPI_TalonSRX leftFront_master = new WPI_TalonSRX(1);
  WPI_TalonSRX leftFront_slave = new WPI_TalonSRX(3);
  SpeedControllerGroup m_left = new SpeedControllerGroup(leftFront_master, leftFront_slave);
  

  WPI_TalonSRX left_liftMaster = new WPI_TalonSRX(5);
  WPI_TalonSRX left_liftSlave = new WPI_TalonSRX(7);
  SpeedControllerGroup leftLift = new SpeedControllerGroup(left_liftSlave, left_liftMaster);

  WPI_TalonSRX right_liftMaster = new WPI_TalonSRX(6);
  WPI_TalonSRX right_liftSlave = new WPI_TalonSRX(8);
  SpeedControllerGroup rightLift = new SpeedControllerGroup(right_liftMaster, right_liftSlave);
  DifferentialDrive lift = new DifferentialDrive(rightLift,leftLift);
 //SpeedControllerGroup lift;
  // tilter 
  WPI_TalonSRX tilt = new WPI_TalonSRX(10);
   
  Servo servo_1 = new Servo(1);
  WPI_TalonSRX fly_wheels = new WPI_TalonSRX(9);
  
  Solenoid front_solenoid = new Solenoid(0);
  Solenoid back_solenoid = new Solenoid(1);

    

    DifferentialDrive m_robotDrive = new DifferentialDrive(m_right , m_left );

    Joystick m_stick = new Joystick(0);
    Joystick xbox = new Joystick(1);
//fly wheel deadband num
  double deadband = 0.25;
//sonic sensors.
  AnalogInput ai = new AnalogInput(0);
  DigitalOutput di = new DigitalOutput(0);
    Timer m_timer = new Timer();
 
  CameraServer RazServer_0 = CameraServer.getInstance();

  /**
   * This function is run when the robot is first started up and should be
   * used for any initialization code.
   */
  @Override
  public void robotInit() {
  
  //CameraServer.getInstance().startAutomaticCapture();


  RazServer_0.addAxisCamera("Raz_0","10.54.98.2:1735");
  RazServer_0.startAutomaticCapture();
 //UsbCamera RazCam_0 = new UsbCamera("RazCam_0", 0);
// CvSink cvSink = new CvSink("opencv_USB RazCam_0");
 //cvSink.setSource(usbCamera);



 //MjpegServer mjpegServer1 = new MjpegServer("Raz_0", 1735);

  }
    
  /**
   * This function is run once each time the robot enters autonomous mode.
   */
  @Override
  public void autonomousInit() {
    m_timer.reset();
    m_timer.start();
  }

  /**
   * This function is called periodically during autonomous.
   */
  @Override
  public void autonomousPeriodic() {
    // Drive for 2 seconds
    
    actTell();
  }

  /**
   * This function is called once each time the robot enters teleoperated mode.
   */
  @Override
  public void teleopInit() {
    
  }

  /**
   * This function is called periodically during teleoperated mode.
   */
  @Override
  public void teleopPeriodic() {
    actTell();
     
  }

  
   // This function is called periodically during test mode.
   
  @Override
  public void testPeriodic() {
  }

  public void actTell() {
      //Xbox input variables   
      double x_left_trigger, x_right_trigger; // triggers on xbox
      boolean x_right_bumper, x_left_bumper;
      boolean x_back_button, x_start_button;
      double x_leftY;
      boolean x_aButton, x_bButton;

      //Joystick input variables
      double j_Axis0, j_Axis1;  //joystick axes
      boolean j_trigger; //index finger trigger
     
    //for sonic distance 
    int sonic_0;
    sonic_0 = ai.getValue();
    sonic_0 = sonic_0 / 2;
    System.out.print(sonic_0);System.out.println("-------------------------------");
    System.out.println("  _ _ _ _ _ _ _ ");
   
   
    //Get all all the inputs from js and xbox
    
    //Joystick
    j_Axis1 =   (m_stick.getRawAxis(1));
    j_Axis0 =   (m_stick.getRawAxis(0));
    j_trigger = (m_stick.getRawButton(1));
    
    //Xbox
    x_leftY = xbox.getRawAxis(1);
    x_left_trigger  = xbox.getRawAxis(2);
    x_right_trigger = xbox.getRawAxis(3);
    x_right_bumper  = xbox.getRawButton(6);
    x_left_bumper   = xbox.getRawButton(5);
    x_back_button = (xbox.getRawButton(7));
    x_start_button = (xbox.getRawButton(8));
    x_aButton = (xbox.getRawButton(1));
    x_bButton = (xbox.getRawButton(2));
    //test light
     if (x_right_bumper == true ){
      di.set(true);
     }else{
       di.set(false);}
    //Speed control (if button is not pressed then speed is slower)
  
    if (j_trigger == true) {
          m_robotDrive.arcadeDrive(j_Axis1  , j_Axis0 );
        }else{  
          m_robotDrive.arcadeDrive(j_Axis1 * 0.5 , j_Axis0 * 0.5 );
        }
     

   //Utilizes trigger output to set fly wheel direction
   //if right is pressed and left is not, that fw is max.
   if (x_right_trigger > deadband && x_left_trigger < deadband){
        fly_wheels.set(1.0);  //setting speed to max.
    }else {
      //if left is pressed and right is not, then fw is -max
      if (x_right_trigger < deadband && x_left_trigger > deadband){
          fly_wheels.set(-1);
      //otherwise, no action on fw.
      }else{
        fly_wheels.set(0);
      }
    }
    //Panel
    //Uses right bumper to set Servo position
    if(x_right_bumper){
      servo_1.setAngle(180);
    }else{ 
      servo_1.setAngle(0);
    }  
 
  //front solenoid to control pneumatic
  if (x_start_button == true && x_left_bumper == true){
    front_solenoid.set(true);
  }else{
    front_solenoid.set(false);
  }
  //back solenoid to control pneumatic
  if (x_back_button == true && x_left_bumper == true){
      back_solenoid.set(true);
    }else{
      back_solenoid.set(false);
    }

  //lift
   if(x_leftY > deadband && !(x_right_bumper)) {
     lift.arcadeDrive(1,0);
   }else if(x_leftY < -0.25 && !(x_right_bumper)){
     lift.arcadeDrive(-1,0);
   }else{
     if(x_leftY > deadband && x_right_bumper){
    lift.arcadeDrive(0.5,0);
  }else if(x_leftY < -0.25 && x_right_bumper){
    lift.arcadeDrive(-0.5,0);
  }else{
    lift.arcadeDrive(0,0);
    }
  }
   //tilt
    if(x_aButton == true && x_bButton == false){
      tilt.set(1);
    }else if(x_aButton == false && x_bButton == true){
      tilt.set(-1);
      }
      else{
     
       tilt.set(0);
      }
       
  }
}
